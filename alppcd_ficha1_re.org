"""ALPpCD_Ficha1_RE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dODJgY0d5_TvV3bmjj8FmSpw3FKgtijt

# Ficha de Expressões Regulares 1

Autor Sofia Santos, ano letivo 24/25 (versão PRH/TJB)

### Conceitos básicos de expressões regulares

- `a` - corresponde a uma ocorrência do caracter `a`.
- `a?` - corresponde a 0 ou 1 ocorrências do caracter `a`.
- `a+` - corresponde a 1 ou mais ocorrências do caracter `a`.
- `a*` - corresponde a 0 ou mais ocorrências do caracter `a`.
- `[abc]` - corresponde a uma ocorrência de um dos caracteres `a`, `b` ou `c`.
- `[a-z]` - corresponde a uma ocorrência de um caracter entre `a` e `z`.
- `^` - corresponde ao início da string.
- `$` - corresponde ao fim da string.
- `[^abc]` - corresponde a uma ocorrência de qualquer caracter que não seja `a`, `b` ou `c`.

Podemos usar o operador de união para unir várias expressões regulares. Por exemplo: `a|bbb|[^a-z]`, que corresponde a uma das várias (neste caso, 3) expressões regulares que fazem parte da união.

Podemos simplificar expressões regulares como `bbb` para `b{3}`, ou seja, 3 ocorrências consecutivas do caracter `b`, neste caso. Outras opções incluem `b{3,}` para 3 ou mais ocorrências ou `b{3,6}` para entre 3 a 6 ocorrências, por exemplo.

Para formar grupos de expressões regulares, usamos parênteses. Por exemplo: `((abc)*|[0-9]+)?`. Os operadores após um grupo atuam sobre o grupo.

Podemos ainda aplicar modificadores a grupos. Por exemplo, `(?i:teste)` corresponde à expressão "teste", escrita com qualquer combinação de maiúsculas e minúsculas (e.g., "TESTE", "tEsTe", "TEste", etc.).

## Exemplos feitos em regex101.com

ER que define um IDENTIFICADOR em qualquer linguagem de programação

[A-Za-z]\w*

## Exercício 1

* Alínea 1.1

Dada uma linha de texto, define um programa que determina se a palavra **"hello"** aparece no início da linha.

Conceitos importantes para este exercício:

- `re.match(pattern, string[, flags])` - analisa a `string` e tenta encontrar uma correspondência para a expressão regular `pattern` a partir do início da string. Devolve `None` se não encontrar nenhuma correspondência.
- `r""` - string correspondente a uma expressão regular.
"""

#+begin_src python :results output
  from re import *

  line1 = "HELLO world"
  line2 = "goodbye world"
  line3 = "hi, hello there"

  #res1 = match(r'(?i:hello)', line1)
  #print(res1)
  #print(res1.group())

  res2 = match(r'(?i:hello)', line1)
  if res2:
    print(res2)
  else:
    print("Não encontrei nada!")

  res3 = match(r'(?i:hello)', line1)
  if res3:
    print(res3.group(0))
  else:
    print("Não encontrei nada!")
#+end_src

#+RESULTS:
: <re.Match object; span=(0, 5), match='HELLO'>
: HELLO


* Alínea 1.2

Dada uma linha de texto, define um programa que determina se a palavra "hello" aparece em qualquer posição da linha.

Conceitos importantes para este exercício:

- `re.search(pattern, string[, flags])` - analisa a `string` e tenta encontrar uma correspondência para a expressão regular `pattern` em qualquer posição da string. Devolve `None` se não encontrar nenhuma correspondência.
"""
#+begin_src python :results output
  import re
  line1 = "hello world"
  line2 = "goodbye world"
  line3 = "hi, helLO there"
  line4 = "HeLLo, Hello, HELLO, hello there! hello, girls!! hello, guys!!!"
  line5 = ""

  res2 = re.search(r'(?i:hello)', line5)
  if res2:
    print(res2)
  else:
    print("Não encontrei nada!")

#+end_src

#+RESULTS:
: Não encontrei nada!

* 1.3

Dada uma linha de texto, define um programa que pesquisa por todas as ocorrências da palavra "hello" dentro da linha, admitindo que a palavra seja escrita com maiúsculas ou minúsculas.

Conceitos importantes para este exercício:

- `re.findall(pattern, string[, flags])` - encontra todas as correspondências que não se sobreponham da expressão regular `pattern` na `string`. Devolve uma lista.
"""

#+begin_src python :results output
  from re import *
  line = "Hello there! Uh, hi, hello, it's me... Heyyy, hello? HELLO!"

  #testInput = input('>> ')
  #while testInput != '':
   # .......
    #testInput = input('>> ')

  res2 = findall(r'(?i:hello)', "")
  if res2:
    print("Ocorreu", len(res2), "vezes")
    print(res2)
  else:
    print("Não encontrei nada!")
#+end_src

#+RESULTS:
: Não encontrei nada!


* Alínea 1.4

Dada uma linha de texto, define um programa que pesquisa por todas as ocorrências da palavra "hello" (**Maiúsculas ou Minúsculas**
) dentro da linha, substituindo cada uma por "\*YEP\*".

Conceitos importantes para este exercício:

- `re.sub(pattern, replacement, string, count = 0)` - substitui todas as correspondências da expressão regular `pattern` na `string` por `replacement`. `replacement` pode ser uma string, uma expressão regular ou uma função que recebe uma correspondência e devolve uma string. O parâmetro opcional `count` determina o limite de substituições (por omissão é 0, ou seja, não há limite).
"""

#+begin_src python :results output
  import re
  line = "Hello there! Uh, hi, hello, it's me... Heyyy, hello? HELLO!"
  line2 = "O meu telemóvel é 954324028 ou 9684122875 ou 931212411. O dele é 203604468. O do zé é 150305152"
  # ...

  def reF(pattern, replacement, string):
    res = re.sub(pattern, replacement , string)
    return res

  print(reF(r"(?i:hello)","*YEP*", line))
  print(reF(r"[0-9]{9}", "*", line2))
  print(reF(r"[29][0-9]{8}", "*", line2))
  print(reF(r"(2[1-9][0-9]{7})|(9[1236][0-9]{7})", "++", line2))
  print(re.sub(r"(?i:[a-zA-Z]+[,?!])","####", line, 3))

#+end_src

#+RESULTS:
: *YEP* there! Uh, hi, *YEP*, it's me... Heyyy, *YEP*? *YEP*!
: O meu telemóvel é * ou *5 ou *. O dele é *. O do zé é *
: O meu telemóvel é * ou *5 ou *. O dele é *. O do zé é 150305152
: O meu telemóvel é 954324028 ou ++5 ou ++. O dele é 203604468. O do zé é 150305152
: Hello #### #### #### hello, it's me... Heyyy, hello? HELLO!

* Alínea 1.5

Dada uma linha de texto, define um programa que pesquisa por todas as ocorrências do caracter vírgula, separando cada parte da linha por esse caracter.

Conceitos importantes para este exercício:

- `re.split(pattern, string, maxsplit = 0)` - divide a `string` com base nas correspondências da expressão regular `pattern`. O parâmetro opcional `maxsplit` pode ser usado para definir um limite de divisões (por omissão é 0, que corresponde a qualquer números de divisões).
"""

** Exercício 1
#+begin_src python :results output
  import re
  line = "bananas, 1 laranjas, 2 maçãs, 3 uvas, 4melancias, 555cerejas, 6 kiwis, etc."

  res = re.sub(r'[0-9]+\s*', '', line)
  res = re.split(r',\s*', res)
  for element in res:
      print(element)
  print(res[3])
  print(res)
  print(type(line))
  print(type(res))
  #
#+end_src

#+RESULTS:
#+begin_example
bananas
laranjas
maçãs
uvas
melancias
cerejas
kiwis
etc.
uvas
['bananas', 'laranjas', 'maçãs', 'uvas', 'melancias', 'cerejas', 'kiwis', 'etc.']
<class 'str'>
<class 'list'>
#+end_example


** Exercício 2

Define a função `palavra_magica` que recebe uma frase e determina se a mesma termina com a expressão "por favor", seguida de um sinal válido de pontuação.
"""

#+begin_src python :results output
  import re

  def palavra_magica(frase):
   value = re.search(r'por favor[.?!]', frase)
   return value


  print(palavra_magica("Posso ir à casa de banho, por favor? miguel"))
  print(palavra_magica("Posso ir à casa de banho, por favor."))
  print(palavra_magica("Preciso de um favor."))
#+end_src

#+RESULTS:
: <re.Match object; span=(26, 36), match='por favor?'>
: <re.Match object; span=(26, 36), match='por favor.'>
: None


** Exercício 3

Define a função `narcissismo` que calcula quantas vezes a palavra "eu" aparece numa string.
"""

#+begin_src python :results output
  import re

  def narcissismo(linha):
    value = len(re.findall(r'(?i:eu)', linha))
    return value

  print(narcissismo("Estáquio disse: Eu não sei se deu, mas eu quero continuar a ser eu, Eufrásia. Por outro lado, eu ser eu é uma parte importante de qeum EU sou."))
#+end_src

#+RESULTS:
: 9


** Exercício 4

Define a função `troca_de_curso` que substitui todas as ocorrências de "LEI" numa linha pelo nome do curso dado à função.
"""

#+begin_src python :results output
  import re

  def troca_de_curso(linha, novo_curso):
    value = re.sub(r'LEI', novo_curso, linha)
    return value

  fonte = "LEI é o melhor curso! Adoro LEI! Gostar de LEI devia ser uma lei."
  curso = input("Novo curso? ")
  print(troca_de_curso(fonte, curso))
#+end_src

#+RESULTS:
: Novo curso?


** Exercício 5

Define a função `soma_string` que recebe uma string com vários números separados por uma vírgula (e.g., "1,2,3,4,5") e devolve a soma destes números.
"""

#+begin_src python :results output
  import re

  def soma_string(linha):
    value = re.split(r',', linha)
    sum = 0
    for i in value:
      sum += int(i)
    return sum

  print(soma_string("4,10,-6,2,3,8,-3,0,2,-5,1"))
#+end_src

#+RESULTS:
: 16


** Exercício 6

Define a função `pronomes` que encontra e devolve todos os pronomes pessoais presentes numa frase, i.e., "eu", "tu", "ele", "ela", etc., com atenção para letras maiúsculas ou minúsculas.

Calcule e mostre também o conjunto dos pronomes encontrados (note que "eu" e "EU" são o mesmo elemento).
"""

#+begin_src python :results output
  import re

  def pronomes(frase):
      value = re.findall('(?i:eu|tu|ele|nós|vós|eles)', frase)
      return value


  def tolower(lista):
    res = []
    for palavra in lista:
      res += [palavra.lower()]
    return res



  frase = "Ola eu vou de certeza. Tu e ele, vêm? Eu não espero por vós. Eu estou com pressa, ele tem de vir!"

  pslist = pronomes(frase)
  pslist = tolower(pslist)
  pslist = set(pslist)
  print('pslist: ',pslist)
#+end_src

#+RESULTS:
: pslist:  {'eu', 'vós', 'tu', 'ele'}



** Exercício 7

Define a função `variavel_valida` que recebe uma string e determina se a mesma é um nome válido para uma variável, ou seja, se começa por uma letra e apenas contém letras, números ou *underscores*.
"""

#+begin_src python :results output
  import re

  def variavel_valida(id):
      value = re.match(r'[a-zA-Z][a-zA-Z\d_]*', id)
      return value


  id = "_tot_1.turma-2"
  id2 = 'arst873_'

  print(variavel_valida(id))
  print(variavel_valida(id2))
#+end_src

#+RESULTS:
: None
: <re.Match object; span=(0, 8), match='arst873_'>



** Exercício 8

Define a função `inteiros` que devolve todos os números inteiros presentes numa string. Um número inteiro pode conter um ou mais dígitos e pode ser positivo ou negativo.
"""

#+begin_src python :results output
  import re


  def inteiros(frase):
      value = re.findall(r'-?[\d]+', frase)
      return value

  frase = "1.23dsds2,22-3-54ola+567"

  print(inteiros(frase))
#+end_src

#+RESULTS:
: 1



** Exercício 9

Define a função `underscores` que substitui todos os espaços numa string por *underscores*. Se aparecerem vários espaços seguidos, devem ser substituídos por apenas um *underscore*."""

#+begin_src python :results output
  import re

  def underscores( frase ):


  print(underscores("Aqui temos   um belo   exemplo   de frase    completamente  maluca  !"))
#+end_src


** Exercício 10

Define a função `codigos_postais` que recebe uma lista de códigos postais válidos e divide-os com base no hífen. A função deve devolver uma lista de pares.
"""

#+begin_src python :results output
  from re import *

  lista = [
      "4700-000",
      "1234-567",
      "8541-543",
      "4123-974",
      "9481-025"
  ]

  def codigos_postais( texto ):

#+end_src
